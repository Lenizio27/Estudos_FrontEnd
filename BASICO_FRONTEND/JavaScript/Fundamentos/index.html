<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamentos sólidos</title>
    <link rel="stylesheet" href="../style.css">
    <link rel="shortcut icon" href="/BASICO_FRONTEND/pdf/a-removebg-preview.png" type="image/x-icon">
</head>
<body>
    <header>
        <div id="DivHeader">
            <h1>Fundamentos JS</h1>
            <nav id="desktopNav">
                <ul class="NavHeader">
                    <li><a href="https://lenizio27.github.io/Estudos_FrontEnd/CHECK_FRONTEND/index.html">Home</a></li>
                </ul>
            </nav>
        </div>
    </header>
    <main>
        <div id="DivMain">
            <!-- TIPOS DE DADOS -->
            <section>
                <h2>Tipos de dados</h2>
                <ul>
                    <li>String:
                        <p> - dados de texto</p>
                    </li>
                    <li>Number:
                        <p> - dados de numeros. ex: 2, 2.5</p>
                    </li>
                    <li>Boolean
                        <p> - dados de valor logico. ex: verdadeiro, falso</p>
                    </li>
                    <li>Undefined:
                        <p> - valor de variavel declara.</p>
                    </li>
                    <li>Null:
                        <p> - valor vazio intencionalmente pelo Dev</p>
                    </li>
                    <li>Symbol
                        <p> - ES6 - dado unico e imutavel</p>
                    </li>
                    <li>BigInt
                        <p> - Numeros maiores que o Number consegue suportar acrescentando "n" no final</p>
                    </li>
                    <li>Dados não-primitivos
                        <p> - Os tipos de dados não-primitivos, ao contrário dos primitivos, não armazenam o valor diretamente. Em vez disso, eles armazenam uma referência (um endereço de memória) para o local onde o valor real está armazenado. Isso significa que, quando você atribui um objeto a uma variável, a variável não contém o objeto em si, mas sim um ponteiro para ele.</p>
                        <p> - Objetos Literais let n = {}: Coleções de pares chave-valor.</p>
                        <p> - Arrays []: Listas ordenadas de valores.</p>
                        <p> - Funções (){}</p>
                    </li>
                </ul>
            </section>
            <!-- VARIAVEIS -->
            <section>
                <h2>Variáveis</h2>
                <ul>
                    <li>var:
                        <p>forma mais antiga, define o valor da variavel</p>
                    </li>
                    <li>let:
                        <p>criada em 2015 no ecmascript6, escopo de bloco, se gerada dentro de uma função so tera importancia dentro de mesma</p>
                    </li>
                    <li>const:
                        <p>tambem criada no ecmascript6, escopo de bloco,maior diferencial é sua imutabilidade.</p>
                    </li>
                </ul>
                <h3>Hoisting</h3>
                <p>Hoisting (que pode ser traduzido como "içamento") é um comportamento do JavaScript em que as declarações de variáveis e funções são "movidas" para o topo do seu escopo antes da execução do código. No entanto, é crucial entender que apenas a declaração é içada, não a inicialização.</p>
                <p>Hoisting de Funções: As declarações de função (function declarations) são completamente içadas, tanto a declaração quanto a sua implementação. Isso permite que você chame uma função antes de sua declaração no código.</p>
            </section>
            <!-- OPERADORES -->
            <section>
                <h2>Operadores</h2>
                <h3>Operadores Aritméticos</h3>
                <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>somar</th>
                            <th>subtrair</th>
                            <th>dividir</th>
                            <th>Multiplicar</th>
                            <th>resto</th>
                            <th>elevado</th>
                            <th>incremento</th>
                            <th>decremento</th>
                        </tr>
                        <tr>
                            <td>+</td>
                            <td>-</td>
                            <td>/</td>
                            <td>*</td>
                            <td>%</td>
                            <td>**</td>
                            <td>++</td>
                            <td>--</td>
                        </tr>
                    </table>
                </aside>
                <h3>Operadores de Atribuição</h3>
                <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>somar</th>
                            <th>subtrair</th>
                            <th>dividir</th>
                            <th>Multiplicar</th>
                            <th>resto</th>
                            <th>elevado</th>
                        </tr>
                        <tr>
                            <td>+=</td>
                            <td>-=</td>
                            <td>/=</td>
                            <td>*=</td>
                            <td>%=</td>
                            <td>**=</td>
                        </tr>
                    </table>
                </aside>
                <h3>Operadores de Comparação(Relacionais)</h3>
                <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>igual</th>
                            <th>Identico</th>
                            <th>diferente</th>
                            <th>est diferente</th>
                            <th>maior que</th>
                            <th>menor que</th>
                            <th>maior/igual</th>
                            <th>menor/igual</th>
                        </tr>
                        <tr>
                            <td>==</td>
                            <td>===</td>
                            <td>!=</td>
                            <td>!==</td>
                            <td>></td>
                            <td><</td>
                            <td>>=</td>
                            <td><=</td>
                        </tr>
                    </table>
                </aside>
                <h3>Operadores Logicos</h3>
                <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>AND</th>
                            <th>OR</th>
                            <th>NOT</th>
                        </tr>
                        <tr>
                            <td>&&</td>
                            <td>||</td>
                            <td>!</td>
                        </tr>
                    </table>
                </aside>
                <h3>Operador Ternario</h3>
                <p>sintaxe: condição ? valor1(caso True) : valor2(caso False)</p>
                <pre>
                    let idade = 20;
                    let status = (idade >= 18) ? "Adulto" : "Menor de idade";
                    console.log(status); // Saída: "Adulto"
                </pre>
                <h3>Operadores de tipo</h3>
                <p>typeof: Retorna uma string indicando o tipo do operando.</p>
                <pre>
                    let n1 = 10;
                    console.log(typeof(n1))
                    result: Number
                </pre>
                <p>instanceof: Retorna true se um objeto é uma instância de um tipo de objeto.</p>
                <pre>
                    let data = new Date(); 
                    data instanceof Date; // true
                </pre>
                <h3>Operador Bittwise(Bit a Bit)</h3>
                <p>Tratam seus operandos como uma sequência de 32 bits (zeros e uns) e realizam operações em nível de bit. São menos comuns em programação web diária, mas úteis em cenários de baixo nível.</p>
                 <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>AND</th>
                            <th>OR</th>
                            <th>XOR</th>
                            <th>NOT</th>
                            <th>Left shift</th>
                            <th>Right shift</th>
                            <th>Zero-fill right shift</th>
                        </tr>
                        <tr>
                            <td>&</td>
                            <td>|</td>
                            <td>^</td>
                            <td>~</td>
                            <td><<</td>
                            <td>>></td>
                            <td>>>></td>
                        </tr>
                    </table>
                </aside>
                <h3>Spread</h3>
                <p>( ... ) : Usado para "espalhar" elementos de um array/objeto ou para agrupar o "resto" dos argumentos de uma função.</p>
            </section>
            <!-- ESTRUTURAS DE CONTROLE -->
            <section>
                <h2>Estruturas de controle</h2>
                <p>Essencialmente, elas se dividem em duas categorias principais: Estruturas Condicionais (para tomar decisões) e Estruturas de Repetição (para executar tarefas repetitivas).</p>
                <h3>Estruturas Condicionais</h3>
                <p>Permitem que seu programa execute diferentes blocos de código com base em se uma condição é verdadeira (true) ou falsa (false).</p>
                <h4>if</h4>
                <p>É a estruturas condicional mais basico, executa uma linha de codigos caso a condição seja verdadeira.</p>
                <pre>
                    let n1 = 10;
                    if(n1 > 0){
                        alert(n1 + " é um número positvo")
                    }
                </pre>
                <h4>if else</h4>
                <p>if else é utilizado quando caso a primeira afirmativa for falsa o else executa o segundo bloco de codigo</p>
                <pre>
                    let n2 = 20;
                    if(n2 <= 10){
                        console.log(n2 + " maior ou igual a 10")
                    }else{
                        console.log(n2 + " menor que 10")
                    }
                </pre>
                <p>obs: o if pode ser usado ao lado do else com um espaçamento caso queira dar uma nova condição para o bloco de codigo alternativo.</p>
                <h4>Switch Case</h4>
                <p>Uma alternativa ao if...else if...else para comparar uma variável com múltiplos valores possíveis. É ótimo para legibilidade quando há muitas condições.</p>
                <pre>
                    let permissao = "gerente";

                    switch (permissao) {
                        case "comum":
                            console.log("Acesso Comum")
                            break;
                        case "gerente":
                            console.log("Acesso exclusivo")
                            break;
                        case "admin";
                            console.log("Acesso total");
                            break
                        default:
                            console.log("Acesso Negado")
                    }
                </pre>
                <h3>Estruturas de Repetição(Loops)</h3>
                <p>Permitem executar um bloco de código repetidamente enquanto uma condição for verdadeira.</p>
                <h4>for</h4>
                <p>O loop mais comum, ideal quando você sabe de antemão quantas vezes quer que o bloco de código seja executado.</p>
               <pre>
                sintaxe:
                    for(inicializacao; condicao; incremento){
                    }
                ex:
                    for (let i = 0; i < 5; i++){
                        console.log("O numero e: " + i)
                    }
               </pre>
               <h4>While(enquanto)</h4>
               <p>Executa um bloco de código enquanto a condição especificada for verdadeira. É ideal quando você não sabe quantas iterações serão necessárias.</p>
               <pre>
                sintaxe: enquanto for true continua
                    while(condição){
                        bloco de condigo
                    }
                ex:
                    let moedas = 10;
                    let tentativas = 0
                    while(moedas > 0){
                        moedas --;
                        tentativas++;
                        console.log("Gastou uma moeda. Restam: " + moedas)
                    }
                    console.log("acabou as moedas")
               </pre>
               <h4>do...while</h4>
               <p>Similar ao while, mas com uma diferença crucial: o bloco de código é executado pelo menos uma vez, pois a condição é verificada após a primeira execução.</p>
               <pre>
                    sintaxe:
                        do{
                            bloco de codigo
                        }while(condição);
                    ex: 
                        let senha;
                        do{
                            senha = prompt("Digite sua senha(deve ter mais de 4 caracteres)")
                        }
               </pre>
               <h4>For...in</h4>
               <p>for...in: Itera sobre as chaves (propriedades) de um objeto.</p>
               <pre>
                    sintaxe:
                        const carro = {marca: "Ford", modelo: "Ka", ano: 2015};
                        for (let chave in carro) {
                        console.log(chave + ": " + carro[chave]); // marca: Ford, modelo: Ka, ano: 2015
                        }
               </pre>
               <h4>For...of</h4>
               <p>for...of: Itera sobre os valores de um objeto iterável (como Arrays, Strings, etc.). É a forma moderna e preferida para percorrer arrays.</p>
               <pre>
                    sintaxe: 
                        const cores = ["vermelho", "verde", "azul"];
                        for (let cor of cores) {
                        console.log(cor); // vermelho, verde, azul
                        }
               </pre>
               <h3>Controle dentro de Loops:</h3>
               <h4>break e continue</h4>
               <p>break: Interrompe e sai completamente do loop.</p>
               <p>continue: Pula a iteração atual e vai para a próxima.</p>
            </section>
            <!-- FUNÇÕES -->
            <section>
                <h2>Funções</h2>
                <h3>O que é uma função</h3>
                <p>
                    Pense em uma função como uma "máquina" ou uma "receita de bolo" que você cria para realizar uma tarefa específica.

                    Você a define uma vez: escreve o código com as instruções dentro dela.

                    Você a executa quantas vezes quiser: "chama" a função pelo nome para que ela execute as instruções.
                </p>
                <h3>Declarando Funções</h3>
                <p>
                    Esta é a forma mais clássica de criar uma função. Ela usa a palavra-chave function, seguida pelo nome da função, uma lista de parâmetros entre parênteses e o bloco de código a ser executado entre chaves.

                    Característica Principal: Sofre hoisting (içamento). Isso significa que você pode chamar a função no seu código antes mesmo de ela ter sido declarada, pois o JavaScript a "move" para o topo do escopo.
                </p>

                <h4>sintaxe:</h4>
                <pre>
                    function nomeDaFuncao(parametro1, parametro2) {
                    // código a ser executado
                    return resultado;
                    }
                </pre>
                <h3>Expressão de Função:</h3>
                <p>
                    Nesta abordagem, você cria uma função (geralmente anônima, ou seja, sem nome) e a atribui a uma variável. A função se torna o valor daquela variável.

                    Característica Principal: Não sofre hoisting. A variável (const ou let) é içada, mas sua atribuição (a função em si) não é. Portanto, você só pode chamar a função depois da linha em que ela foi definida.
                </p>
                <pre>
                    const nomeDaVariavel = function(parametro1, parametro2) {
                    // código a ser executado
                    return resultado;
                    }; // Note o ponto e vírgula opcional aqui, pois é uma atribuição

                    ex: 
                    const despedida = function(nome) {
                    console.log("Até mais, " + nome + "!");
                    };
                    despedida("Carlos"); // Saída: "Até mais, Carlos!"
                </pre>
                <h3>Arrow Function</h3>
                <p>
                    Introduzidas no ES6, as arrow functions oferecem uma sintaxe mais curta e concisa, além de terem um comportamento diferente com a palavra-chave this (elas não têm seu próprio this, herdam do escopo ao redor).
                </p>
                <h4>caracteristicas:</h4>
                <ul>
                    <li>Sintaxe curta.</li>
                    <li>Retorno implícito se não houver chaves {}.</li>
                    <li>Sempre anônimas, precisam ser atribuídas a uma variável.</li>
                    <li>Não sofrem hoisting</li>
                </ul>
                <pre>
                    // Sintaxe completa
                    const somar = (a, b) => {
                    return a + b;
                    };

                    // Se houver apenas uma linha de retorno, pode omitir {} e 'return'
                    const subtrair = (a, b) => a - b;

                    // Se houver apenas um parâmetro, pode omitir os parênteses ()
                    const dobrar = numero => numero * 2;

                    // Sem parâmetros
                    const darOi = () => "Oi!";

                    ex: 
                    const calcularArea = (largura, altura) => largura * altura;

                    let area = calcularArea(10, 5);
                    console.log(area); // Saída: 50
                </pre>
                <h3>Parâmetros e Argumentos</h3>
                <ul>
                    <li><strong>Parâmetros</strong>: São as "variáveis" listadas na definição da função. Funcionam como placeholders para os valores que a função espera receber.</li>
                    <li><strong>Argumentos</strong>: São os valores reais que você passa para a função quando a chama.</li>
                </ul>
                <pre>
                    // 'a' e 'b' são PARÂMETROS
                    function multiplicar(a, b) {
                    return a * b;
                    }

                    // 10 e 5 são ARGUMENTOS
                    let resultado = multiplicar(10, 5);
                </pre>
                <h3>Recursos Modernos para Parâmetros (ES6+):</h3>
                <p>
                    Parâmetros Padrão (Default Parameters): Você pode definir um valor padrão para um parâmetro, caso nenhum argumento seja fornecido para ele.
                </p>
                <pre>
                    function registrarUsuario(nome, plano = "Básico") {
                    console.log(`${nome} registrado no plano ${plano}.`);
                    }

                    registrarUsuario("Bia"); // Saída: Bia registrado no plano Básico.
                    registrarUsuario("Leo", "Premium"); // Saída: Leo registrado no plano Premium.
                </pre>
                <p>
                    Parâmetros Rest (Rest Parameters): Permite que uma função aceite um número indefinido de argumentos como um array.
                </p>
                <pre>
                    function somarTodos(...numeros) {
                    let total = 0;
                    for (let num of numeros) {
                        total += num;
                    }
                    return total;
                    }
                    console.log(somarTodos(1, 2, 3));      // Saída: 6
                    console.log(somarTodos(10, 20, 30, 40)); // Saída: 100
                </pre>
                <h3>Return em Funções</h3>
                <ul>
                    <li>a função pode ter apenas um return.</li>
                    <li>Qualquer código após o return dentro da função não será executado.</li>
                    <li>Se uma função não tiver uma instrução return, ela retornará undefined por padrão.</li>
                </ul>
                <pre>
                    function isMaiorDeIdade(idade) {
                    if (idade >= 18) {
                        return true; // A função para aqui e retorna true
                    }
                    // Esta linha só é alcançada se a condição do if for falsa
                    return false; 
                    }

                    let podeDirigir = isMaiorDeIdade(25); // podeDirigir agora tem o valor 'true'

                    if (podeDirigir) {
                    console.log("Pode tirar a carteira de motorista!");
                    }
                </pre>
            </section>
            <!-- ARRAYS E OBJETOS -->
            <section>
                <h2>Arrays e Objetos</h2>
                <p>
                    Tanto Objetos quanto Arrays são usados para armazenar uma coleção de dados. A grande diferença está em como eles organizam e como você acessa esses dados.
                </p>
                <ul>
                    <li>
                        <strong>Arrays</strong>: Pense em uma lista ordenada, como uma lista de compras ou uma fila de pessoas. A ordem dos itens importa e você os acessa pela sua posição (índice).
                    </li>
                    <li>
                        <strong>Objetos</strong>: Pense em uma ficha de cadastro ou um dicionário. Você tem um conjunto de propriedades (ou "rótulos") e cada um tem um valor associado. A ordem geralmente não importa, e você acessa os valores através dos seus nomes (chaves).
                    </li>
                </ul>
                <aside>
                    <h3>Objetos</h3>
                    <p>
                        Um objeto é uma coleção de pares chave-valor (key-value pairs).
                    </p>
                    <ul>
                        <li>Chave (Key): É o nome da propriedade (um texto, ou string).</li>
                        <li>Valor (Value): Pode ser qualquer tipo de dado: um texto, um número, um booleano, um array ou até mesmo outro objeto ou uma função.</li>
                    </ul>
                    <p>
                        <strong>Quando usar</strong>? Quando você tem um conjunto de dados que descrevem uma única "coisa", onde cada dado tem um rótulo claro. Ideal para representar itens como um usuário, um produto, um carro, etc.
                    </p>
                    <pre>
                        sintaxe:
                        let carro = {
                            // chave: valor
                            marca: "Ford",
                            modelo: "Ka",
                            ano: 2015,
                            ligado: false,
                            ligar: function() { // O valor pode ser uma função (método)
                                this.ligado = true;
                                console.log("Carro ligado!");
                            }
                            };
                    </pre>

                    <h4>Acessando Dados de um Objeto</h4>
                    <p>1. Notação de Ponto (Dot Notation): Mais comum e fácil de ler</p>
                    <pre>
                        console.log(carro.marca); // Saída: "Ford"
                        console.log(carro.ano);   // Saída: 2015
                    </pre>
                    <p>
                        2. Notação de Colchetes (Bracket Notation): Mais flexível. Necessária quando a chave contém espaços, caracteres especiais ou quando o nome da chave está em uma variável.
                    </p>
                    <pre>
                        console.log(carro['modelo']); // Saída: "Ka"
                        let propriedade = 'ano';
                        console.log(carro[propriedade]); // Saída: 2015 -> Acessa a chave contida na variável
                    </pre>
                    <h4>Modificando um Objeto</h4>
                    <p>
                        Você pode adicionar, alterar ou remover propriedades a qualquer momento.
                    </p>
                    <pre>
                        // Alterando um valor
                        carro.ano = 2018;
                        console.log(carro.ano); // Saída: 2018

                        // Adicionando uma nova propriedade
                        carro.cor = "Branco";
                        console.log(carro.cor); // Saída: "Branco"

                        // Removendo uma propriedade
                        delete carro.ligado;
                        console.log(carro.ligado); // Saída: undefined
                    </pre>
                </aside>
                <aside>
                    <h3>Arrays</h3>
                    <p>
                        Um array é uma lista ordenada de valores. Cada valor é chamado de elemento, e cada elemento possui um índice (sua posição na lista), que começa em 0.
                        <br>
                        Quando usar? Quando você tem uma coleção de itens similares e a ordem deles é importante ou quando você simplesmente precisa de uma lista. Ideal para representar itens como uma lista de tarefas, uma coleção de notas, uma sequência de nomes.
                    </p>
                    <pre>
                        // Criando um array 'compras' usando a sintaxe literal []
                        let compras = ["Arroz", "Feijão", "Batata", "Macarrão"];

                        // Um array pode ter tipos de dados misturados (embora seja mais comum ter tipos iguais)
                        let dadosVariados = ["João", 30, true, { cidade: "Fortaleza" }];
                    </pre>
                    <h4>Acessando Dados de um Array</h4>
                    <pre>
                        //Você sempre usa a notação de colchetes com o índice do elemento.
                        console.log(compras[0]); // Saída: "Arroz" (o primeiro elemento é o índice 0)
                        console.log(compras[2]); // Saída: "Batata"
                    </pre>
                    <h4>Propriedades e Métodos Comuns</h4>
                    <p>Arrays vêm com muitas "ferramentas" (propriedades e métodos) úteis.</p>
                    <p>.length: Retorna a quantidade de elementos no array.</p>
                    <pre>
                        console.log(compras.length); // Saída: 4
                    </pre>
                    <p>.push(): Adiciona um ou mais elementos no final do array.</p>
                    <pre>
                        compras.push("Frango");
                        console.log(compras); // ["Arroz", "Feijão", "Batata", "Macarrão", "Frango"]
                    </pre>
                    <p>.pop(): Remove o último elemento do array.</p>
                    <pre>
                        compras.pop(); // Remove "Frango"
                    </pre>
                    <p>.forEach(): Executa uma função para cada elemento do array. Ótimo para percorrer a lista.</p>
                    <pre>
                        compras.forEach(function(item, indice) {
                        console.log(`Item ${indice}: ${item}`);
                        });
                    </pre>
                    <a href="../pdf/array_js_propriedades_metodos.pdf">Array</a>
                </aside>
                <h4>O Poder da Combinação: O Mais Comum na Prática</h4>
                <p>
                    No mundo real, a maioria das estruturas de dados complexas (como as que vêm de uma API) são uma combinação de arrays e objetos.
                    <br>
                    Por exemplo, você pode ter uma lista (array) de usuários, onde cada usuário é um objeto com suas próprias propriedades.
                </p>

                <pre>
                    let usuarios = [
                    { // Objeto no índice 0
                        id: 1,
                        nome: "Ana Silva",
                        email: "ana@email.com",
                        ativo: true
                    },
                    { // Objeto no índice 1
                        id: 2,
                        nome: "Bruno Costa",
                        email: "bruno@email.com",
                        ativo: false
                    },
                    { // Objeto no índice 2
                        id: 3,
                        nome: "Carlos Souza",
                        email: "carlos@email.com",
                        ativo: true
                    }
                    ];

                    // Como acessar o e-mail do segundo usuário?
                    // 1. Acesse o elemento de índice 1 do array: usuarios[1]
                    // 2. Desse objeto retornado, acesse a propriedade 'email': .email
                    console.log(usuarios[1].email); // Saída: "bruno@email.com"

                    // Como encontrar todos os usuários ativos? (usando o método .filter de array)
                    let usuariosAtivos = usuarios.filter(function(usuario) {
                    return usuario.ativo === true;
                    });

                    console.log(usuariosAtivos); // Retorna um novo array com os objetos de Ana e Carlos
                </pre>
            </section>
            <!-- DOM -->
            <section>
                <h2>O que é o DOM?</h2>
                <p>
                    Pense no seu arquivo HTML como uma planta arquitetônica de uma casa. Quando o navegador lê essa planta, ele constrói a casa de verdade. O DOM (Document Object Model) é essa "casa construída" na memória do navegador.
                    <br>
                    É uma representação do seu HTML em formato de objetos, organizados em uma estrutura de árvore. Cada tag (h1, p, div, button) se torna um "nó" ou um objeto nessa árvore.
                </p>
                <h3>O JavaScript pode interagir com essa árvore. Ele pode:</h3>
                <ul>
                    <li>Ler a árvore (encontrar qualquer elemento).</li>
                    <li>Modificar a árvore (mudar textos, estilos, atributos).</li>
                    <li>Ouvir o que acontece na árvore (eventos como cliques, digitação, etc.).</li>
                </ul>
                <p>
                    Qualquer mudança que o JavaScript faz no DOM é refletida instantaneamente na página que o usuário vê
                </p>
                <h3>querySelector</h3>
                <p>
                    Antes de manipular um elemento, você precisa encontrá-lo e "pegá-lo". O querySelector é a ferramenta moderna e mais poderosa para isso.
                </p>

                <p>
                    document.querySelector(seletor): Retorna o primeiro elemento da página que corresponde ao seletor CSS fornecido. Se nenhum for encontrado, retorna null.
                </p>

                <pre>
                    // Selecionar um elemento pelo seu ID (#)
                    const tituloPrincipal = document.querySelector('#titulo-principal');

                    // Selecionar um elemento pela sua classe (.)
                    const primeiroParagrafo = document.querySelector('.paragrafo');

                    // Selecionar um elemento pelo nome da tag
                    const cabecalho = document.querySelector('header');

                    // Selecionar um botão que está desabilitado (seletor de atributo)
                    const botaoInativo = document.querySelector('button[disabled]');

                    // Selecionar um link com a classe 'ativo' dentro do menu principal
                    const linkAtivo = document.querySelector('nav .link-ativo');
                </pre>
                <h3>querySelectorAll</h3>
                <p>
                    document.querySelectorAll(seletor): Retorna uma NodeList (que é muito parecida com um array) com todos os elementos que correspondem ao seletor.
                </p>
                <pre>
                    / Pega todos os parágrafos com a classe 'item'
                    const todosOsItens = document.querySelectorAll('.item');

                    // Como é uma lista, podemos usar .forEach para percorrer cada um
                    todosOsItens.forEach(function(item) {
                    console.log(item.textContent); // Imprime o texto de cada item
                    });
                </pre>
                <h3>Eventos</h3>
                <p>
                    Eventos são "sinais" que o navegador emite para avisar que algo aconteceu na página. O JavaScript pode "ouvir" esses sinais para disparar uma ação.
                    <br>
                    Alguns dos eventos mais comuns são:
                </p>
                <ul>
                    <li><strong>click</strong>: Quando um elemento é clicado com o mouse.</li>

                    <li><strong>mouseover</strong>: Quando o ponteiro do mouse passa por cima de um elemento.</li>

                    <li><strong>mouseout</strong>: Quando o ponteiro do mouse sai de um elemento.</li>

                    <li><strong>keydown</strong>: Quando uma tecla do teclado é pressionada.</li>

                    <li><strong>keyup</strong>: Quando uma tecla do teclado é solta.</li>

                    <li><strong>submit</strong>: Quando um formulário (form) é enviado.</li>

                    <li><strong>focus</strong>: Quando um elemento de formulário (como um input) recebe o foco.</li>

                    <li><strong>blur</strong>: Quando um elemento de formulário perde o foco.</li>

                    <li><strong>load</strong>: Quando a página ou um recurso (como uma imagem) termina de carregar.</li>
                </ul>
                <h3>addEventListener</h3>
                <p>
                    Esta é a "cola" que une tudo. O método addEventListener "anexa um ouvinte de evento" a um elemento que você selecionou.
                </p>
                <pre>
                    sintaxe:
                    elemento.addEventListener('tipoDoEvento', funcaoCallback);
                </pre>
                <ul>
                    <li>elemento: A variável que contém o elemento selecionado com querySelector.</li>

                    <li>'tipoDoEvento': Uma string com o nome do evento que queremos ouvir (ex: 'click').</li>

                    <li>funcaoCallback: A função que será executada automaticamente quando o evento ocorrer naquele elemento. "Callback" significa que é uma função que você passa para ser "chamada de volta" mais tarde.</li>
                </ul>

                <h3>fluxo de trabalho</h3>
                <ul>
                    <li>SELECIONAR o(s) elemento(s) que você quer manipular (querySelector).</li>

                    <li>ESPERAR por uma ação do usuário (addEventListener).</li>

                    <li>REAGIR à ação, executando uma função que modifica o DOM (alterando texto, estilo, classes, etc.).</li>
                </ul>
            </section>
        </div>
    </main>
    <script src="index.js"></script>
</body>
</html>
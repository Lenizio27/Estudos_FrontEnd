<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamentos sólidos</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <div id="DivHeader">
            <h1>Fundamentos JS</h1>
            <nav>
                <ul class="NavHeader">
                    <li><a href="https://lenizio27.github.io/Estudos_FrontEnd/CHECK_FRONTEND/index.html">Home</a></li>
                    <li><a href="">Dados</a></li>
                    <li><a href="">Variaveis</a></li>
                    <li><a href="">Operadores</a></li>
                </ul>
            </nav>
        </div>
    </header>
    <main>
        <div id="DivMain">
            <section>
                <h2>Tipos de dados</h2>
                <ul>
                    <li>String:
                        <p> - dados de texto</p>
                    </li>
                    <li>Number:
                        <p> - dados de numeros. ex: 2, 2.5</p>
                    </li>
                    <li>Boolean
                        <p> - dados de valor logico. ex: verdadeiro, falso</p>
                    </li>
                    <li>Undefined:
                        <p> - valor de variavel declara.</p>
                    </li>
                    <li>Null:
                        <p> - valor vazio intencionalmente pelo Dev</p>
                    </li>
                    <li>Symbol
                        <p> - ES6 - dado unico e imutavel</p>
                    </li>
                    <li>BigInt
                        <p> - Numeros maiores que o Number consegue suportar acrescentando "n" no final</p>
                    </li>
                    <li>Dados não-primitivos
                        <p> - Os tipos de dados não-primitivos, ao contrário dos primitivos, não armazenam o valor diretamente. Em vez disso, eles armazenam uma referência (um endereço de memória) para o local onde o valor real está armazenado. Isso significa que, quando você atribui um objeto a uma variável, a variável não contém o objeto em si, mas sim um ponteiro para ele.</p>
                        <p> - Objetos Literais let n = {}: Coleções de pares chave-valor.</p>
                        <p> - Arrays []: Listas ordenadas de valores.</p>
                        <p> - Funções (){}</p>
                    </li>
                </ul>
            </section>
            <section>
                <h2>Variáveis</h2>
                <ul>
                    <li>var:
                        <p>forma mais antiga, define o valor da variavel</p>
                    </li>
                    <li>let:
                        <p>criada em 2015 no ecmascript6, escopo de bloco, se gerada dentro de uma função so tera importancia dentro de mesma</p>
                    </li>
                    <li>const:
                        <p>tambem criada no ecmascript6, escopo de bloco,maior diferencial é sua imutabilidade.</p>
                    </li>
                </ul>
                <h3>Hoisting</h3>
                <p>Hoisting (que pode ser traduzido como "içamento") é um comportamento do JavaScript em que as declarações de variáveis e funções são "movidas" para o topo do seu escopo antes da execução do código. No entanto, é crucial entender que apenas a declaração é içada, não a inicialização.</p>
                <p>Hoisting de Funções: As declarações de função (function declarations) são completamente içadas, tanto a declaração quanto a sua implementação. Isso permite que você chame uma função antes de sua declaração no código.</p>
            </section>
            <section>
                <h2>Operadores</h2>
                <h3>Operadores Aritméticos</h3>
                <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>somar</th>
                            <th>subtrair</th>
                            <th>dividir</th>
                            <th>Multiplicar</th>
                            <th>resto</th>
                            <th>elevado</th>
                            <th>incremento</th>
                            <th>decremento</th>
                        </tr>
                        <tr>
                            <td>+</td>
                            <td>-</td>
                            <td>/</td>
                            <td>*</td>
                            <td>%</td>
                            <td>**</td>
                            <td>++</td>
                            <td>--</td>
                        </tr>
                    </table>
                </aside>
                <h3>Operadores de Atribuição</h3>
                <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>somar</th>
                            <th>subtrair</th>
                            <th>dividir</th>
                            <th>Multiplicar</th>
                            <th>resto</th>
                            <th>elevado</th>
                        </tr>
                        <tr>
                            <td>+=</td>
                            <td>-=</td>
                            <td>/=</td>
                            <td>*=</td>
                            <td>%=</td>
                            <td>**=</td>
                        </tr>
                    </table>
                </aside>
                <h3>Operadores de Comparação(Relacionais)</h3>
                <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>igual</th>
                            <th>Identico</th>
                            <th>diferente</th>
                            <th>est diferente</th>
                            <th>maior que</th>
                            <th>menor que</th>
                            <th>maior/igual</th>
                            <th>menor/igual</th>
                        </tr>
                        <tr>
                            <td>==</td>
                            <td>===</td>
                            <td>!=</td>
                            <td>!==</td>
                            <td>></td>
                            <td><</td>
                            <td>>=</td>
                            <td><=</td>
                        </tr>
                    </table>
                </aside>
                <h3>Operadores Logicos</h3>
                <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>AND</th>
                            <th>OR</th>
                            <th>NOT</th>
                        </tr>
                        <tr>
                            <td>&&</td>
                            <td>||</td>
                            <td>!</td>
                        </tr>
                    </table>
                </aside>
                <h3>Operador Ternario</h3>
                <p>sintaxe: condição ? valor1(caso True) : valor2(caso False)</p>
                <pre>
                    let idade = 20;
                    let status = (idade >= 18) ? "Adulto" : "Menor de idade";
                    console.log(status); // Saída: "Adulto"
                </pre>
                <h3>Operadores de tipo</h3>
                <p>typeof: Retorna uma string indicando o tipo do operando.</p>
                <pre>
                    let n1 = 10;
                    console.log(typeof(n1))
                    result: Number
                </pre>
                <p>instanceof: Retorna true se um objeto é uma instância de um tipo de objeto.</p>
                <pre>
                    let data = new Date(); 
                    data instanceof Date; // true
                </pre>
                <h3>Operador Bittwise(Bit a Bit)</h3>
                <p>Tratam seus operandos como uma sequência de 32 bits (zeros e uns) e realizam operações em nível de bit. São menos comuns em programação web diária, mas úteis em cenários de baixo nível.</p>
                 <aside class="AlignBox">
                    <table>
                        <tr>
                            <th>AND</th>
                            <th>OR</th>
                            <th>XOR</th>
                            <th>NOT</th>
                            <th>Left shift</th>
                            <th>Right shift</th>
                            <th>Zero-fill right shift</th>
                        </tr>
                        <tr>
                            <td>&</td>
                            <td>|</td>
                            <td>^</td>
                            <td>~</td>
                            <td><<</td>
                            <td>>></td>
                            <td>>>></td>
                        </tr>
                    </table>
                </aside>
                <h3>Spread</h3>
                <p>( ... ) : Usado para "espalhar" elementos de um array/objeto ou para agrupar o "resto" dos argumentos de uma função.</p>
            </section>
            <section>
                <h2>Estruturas de controle</h2>
                <p>Essencialmente, elas se dividem em duas categorias principais: Estruturas Condicionais (para tomar decisões) e Estruturas de Repetição (para executar tarefas repetitivas).</p>
                <h3>Estruturas Condicionais</h3>
                <p>Permitem que seu programa execute diferentes blocos de código com base em se uma condição é verdadeira (true) ou falsa (false).</p>
                <h4>if</h4>
                <p>É a estruturas condicional mais basico, executa uma linha de codigos caso a condição seja verdadeira.</p>
                <pre>
                    let n1 = 10;
                    if(n1 > 0){
                        alert(n1 + " é um número positvo")
                    }
                </pre>
                <h4>if else</h4>
                <p>if else é utilizado quando caso a primeira afirmativa for falsa o else executa o segundo bloco de codigo</p>
                <pre>
                    let n2 = 20;
                    if(n2 <= 10){
                        console.log(n2 + " maior ou igual a 10")
                    }else{
                        console.log(n2 + " menor que 10")
                    }
                </pre>
                <p>obs: o if pode ser usado ao lado do else com um espaçamento caso queira dar uma nova condição para o bloco de codigo alternativo.</p>
                <h4>Switch Case</h4>
                <p>Uma alternativa ao if...else if...else para comparar uma variável com múltiplos valores possíveis. É ótimo para legibilidade quando há muitas condições.</p>
                <pre>
                    let permissao = "gerente";

                    switch (permissao) {
                        case "comum":
                            console.log("Acesso Comum")
                            break;
                        case "gerente":
                            console.log("Acesso exclusivo")
                            break;
                        case "admin";
                            console.log("Acesso total");
                            break
                        default:
                            console.log("Acesso Negado")
                    }
                </pre>
                <h3>Estruturas de Repetição(Loops)</h3>
                <p>Permitem executar um bloco de código repetidamente enquanto uma condição for verdadeira.</p>
                <h4>for</h4>
                <p>O loop mais comum, ideal quando você sabe de antemão quantas vezes quer que o bloco de código seja executado.</p>
               <pre>
                sintaxe:
                    for(inicializacao; condicao; incremento){
                    }
                ex:
                    for (let i = 0; i < 5; i++){
                        console.log("O numero e: " + i)
                    }
               </pre>
               <h4>While(enquanto)</h4>
               <p>Executa um bloco de código enquanto a condição especificada for verdadeira. É ideal quando você não sabe quantas iterações serão necessárias.</p>
               <pre>
                sintaxe: enquanto for true continua
                    while(condição){
                        bloco de condigo
                    }
                ex:
                    let moedas = 10;
                    let tentativas = 0
                    while(moedas > 0){
                        moedas --;
                        tentativas++;
                        console.log("Gastou uma moeda. Restam: " + moedas)
                    }
                    console.log("acabou as moedas")
               </pre>
               <h4>do...while</h4>
               <p>Similar ao while, mas com uma diferença crucial: o bloco de código é executado pelo menos uma vez, pois a condição é verificada após a primeira execução.</p>
               <pre>
                    sintaxe:
                        do{
                            bloco de codigo
                        }while(condição);
                    ex: 
                        let senha;
                        do{
                            senha = prompt("Digite sua senha(deve ter mais de 4 caracteres)")
                        }
               </pre>
               <h4>For...in</h4>
               <p>for...in: Itera sobre as chaves (propriedades) de um objeto.</p>
               <pre>
                    sintaxe:
                        const carro = {marca: "Ford", modelo: "Ka", ano: 2015};
                        for (let chave in carro) {
                        console.log(chave + ": " + carro[chave]); // marca: Ford, modelo: Ka, ano: 2015
                        }
               </pre>
               <h4>For...of</h4>
               <p>for...of: Itera sobre os valores de um objeto iterável (como Arrays, Strings, etc.). É a forma moderna e preferida para percorrer arrays.</p>
               <pre>
                    sintaxe: 
                        const cores = ["vermelho", "verde", "azul"];
                        for (let cor of cores) {
                        console.log(cor); // vermelho, verde, azul
                        }
               </pre>
               <h3>Controle dentro de Loops:</h3>
               <h4>break e continue</h4>
               <p>break: Interrompe e sai completamente do loop.</p>
               <p>continue: Pula a iteração atual e vai para a próxima.</p>
            </section>
            <section>
                <h2>Funções</h2>
                <h3>O que é uma função</h3>
                <p>
                    Pense em uma função como uma "máquina" ou uma "receita de bolo" que você cria para realizar uma tarefa específica.

                    Você a define uma vez: escreve o código com as instruções dentro dela.

                    Você a executa quantas vezes quiser: "chama" a função pelo nome para que ela execute as instruções.
                </p>
                <h3>Declarando Funções</h3>
                <p>
                    Esta é a forma mais clássica de criar uma função. Ela usa a palavra-chave function, seguida pelo nome da função, uma lista de parâmetros entre parênteses e o bloco de código a ser executado entre chaves.

                    Característica Principal: Sofre hoisting (içamento). Isso significa que você pode chamar a função no seu código antes mesmo de ela ter sido declarada, pois o JavaScript a "move" para o topo do escopo.
                </p>

                <h4>sintaxe:</h4>
                <pre>
                    function nomeDaFuncao(parametro1, parametro2) {
                    // código a ser executado
                    return resultado;
                    }
                </pre>
                <h3>Expressão de Função:</h3>
                <p>
                    Nesta abordagem, você cria uma função (geralmente anônima, ou seja, sem nome) e a atribui a uma variável. A função se torna o valor daquela variável.

                    Característica Principal: Não sofre hoisting. A variável (const ou let) é içada, mas sua atribuição (a função em si) não é. Portanto, você só pode chamar a função depois da linha em que ela foi definida.
                </p>
                <pre>
                    const nomeDaVariavel = function(parametro1, parametro2) {
                    // código a ser executado
                    return resultado;
                    }; // Note o ponto e vírgula opcional aqui, pois é uma atribuição

                    ex: 
                    const despedida = function(nome) {
                    console.log("Até mais, " + nome + "!");
                    };
                    despedida("Carlos"); // Saída: "Até mais, Carlos!"
                </pre>
                <h3>Arrow Function</h3>
                <p>
                    Introduzidas no ES6, as arrow functions oferecem uma sintaxe mais curta e concisa, além de terem um comportamento diferente com a palavra-chave this (elas não têm seu próprio this, herdam do escopo ao redor).
                </p>
                <h4>caracteristicas:</h4>
                <ul>
                    <li>Sintaxe curta.</li>
                    <li>Retorno implícito se não houver chaves {}.</li>
                    <li>Sempre anônimas, precisam ser atribuídas a uma variável.</li>
                    <li>Não sofrem hoisting</li>
                </ul>
                <pre>
                    // Sintaxe completa
                    const somar = (a, b) => {
                    return a + b;
                    };

                    // Se houver apenas uma linha de retorno, pode omitir {} e 'return'
                    const subtrair = (a, b) => a - b;

                    // Se houver apenas um parâmetro, pode omitir os parênteses ()
                    const dobrar = numero => numero * 2;

                    // Sem parâmetros
                    const darOi = () => "Oi!";

                    ex: 
                    const calcularArea = (largura, altura) => largura * altura;

                    let area = calcularArea(10, 5);
                    console.log(area); // Saída: 50
                </pre>
                <h3>Parâmetros e Argumentos</h3>
                <ul>
                    <li><strong>Parâmetros</strong>: São as "variáveis" listadas na definição da função. Funcionam como placeholders para os valores que a função espera receber.</li>
                    <li><strong>Argumentos</strong>: São os valores reais que você passa para a função quando a chama.</li>
                </ul>
                <pre>
                    // 'a' e 'b' são PARÂMETROS
                    function multiplicar(a, b) {
                    return a * b;
                    }

                    // 10 e 5 são ARGUMENTOS
                    let resultado = multiplicar(10, 5);
                </pre>
                <h3>Recursos Modernos para Parâmetros (ES6+):</h3>
            </section>
        </div>
    </main>
    <script src="index.js"></script>
</body>
</html>